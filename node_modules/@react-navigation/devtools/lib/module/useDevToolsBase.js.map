{"version":3,"sources":["useDevToolsBase.tsx"],"names":["deepEqual","React","parseErrorStack","useDevToolsBase","ref","callback","lastStateRef","useRef","lastActionRef","callbackRef","lastResetRef","undefined","useEffect","current","symbolicate","stack","frames","slice","filter","frame","file","urlMatch","match","result","fetch","method","body","JSON","stringify","then","res","json","it","collapse","map","methodName","lineNumber","column","join","err","pendingPromiseRef","Promise","resolve","send","useCallback","data","catch","timer","unsubscribeAction","unsubscribeState","initialize","setInterval","clearTimeout","state","getRootState","type","navigation","addListener","e","action","noop","lastState","lastChange","resetRoot"],"mappings":"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","sourcesContent":["import type {\n  NavigationAction,\n  NavigationContainerRef,\n  NavigationState,\n} from '@react-navigation/core';\nimport deepEqual from 'deep-equal';\nimport * as React from 'react';\n\nimport parseErrorStack from './parseErrorStack';\n\ntype StackFrame = {\n  lineNumber: number | null;\n  column: number | null;\n  file: string | null;\n  methodName: string;\n};\n\ntype StackFrameResult = StackFrame & {\n  collapse: boolean;\n};\n\ntype StackResult = {\n  stack: StackFrameResult[];\n};\n\ntype InitData = {\n  type: 'init';\n  state: NavigationState | undefined;\n};\n\ntype ActionData = {\n  type: 'action';\n  action: NavigationAction;\n  state: NavigationState | undefined;\n  stack: string | undefined;\n};\n\nexport default function useDevToolsBase(\n  ref: React.RefObject<NavigationContainerRef<any>>,\n  callback: (result: InitData | ActionData) => void\n) {\n  const lastStateRef = React.useRef<NavigationState | undefined>();\n  const lastActionRef = React.useRef<\n    { action: NavigationAction; stack: string | undefined } | undefined\n  >();\n  const callbackRef = React.useRef(callback);\n  const lastResetRef = React.useRef<NavigationState | undefined>(undefined);\n\n  React.useEffect(() => {\n    callbackRef.current = callback;\n  });\n\n  const symbolicate = async (stack: string | undefined) => {\n    if (stack == null) {\n      return undefined;\n    }\n\n    const frames = parseErrorStack(stack)\n      .slice(2)\n      .filter((frame) => frame.file !== '[native code]');\n\n    const urlMatch = frames[0]?.file?.match(/^https?:\\/\\/.+(:\\d+)?\\//);\n\n    if (!urlMatch) {\n      return stack;\n    }\n\n    try {\n      const result: StackResult = await fetch(`${urlMatch[0]}symbolicate`, {\n        method: 'POST',\n        body: JSON.stringify({ stack: frames }),\n      }).then((res) => res.json());\n\n      return result.stack\n        .filter((it) => !it.collapse)\n        .map(\n          ({ methodName, file, lineNumber, column }) =>\n            `${methodName}@${file}:${lineNumber}:${column}`\n        )\n        .join('\\n');\n    } catch (err) {\n      return stack;\n    }\n  };\n\n  const pendingPromiseRef = React.useRef<Promise<void>>(Promise.resolve());\n\n  const send = React.useCallback((data: ActionData) => {\n    // We need to make sure that our callbacks executed in the same order\n    // So we add check if the last promise is settled before sending the next one\n    pendingPromiseRef.current = pendingPromiseRef.current\n      .catch(() => {\n        // Ignore any errors from the last promise\n      })\n      .then(async () => {\n        if (data.stack) {\n          let stack: string | undefined;\n\n          try {\n            stack = await symbolicate(data.stack);\n          } catch (err) {\n            // Ignore errors from symbolicate\n          }\n\n          callbackRef.current({ ...data, stack });\n        } else {\n          callbackRef.current(data);\n        }\n      });\n  }, []);\n\n  React.useEffect(() => {\n    let timer: any;\n    let unsubscribeAction: (() => void) | undefined;\n    let unsubscribeState: (() => void) | undefined;\n\n    const initialize = async () => {\n      if (!ref.current) {\n        // If the navigation object isn't ready yet, wait for it\n        await new Promise<void>((resolve) => {\n          timer = setInterval(() => {\n            if (ref.current) {\n              resolve();\n              clearTimeout(timer);\n              const state = ref.current.getRootState();\n\n              lastStateRef.current = state;\n              callbackRef.current({ type: 'init', state });\n            }\n          }, 100);\n        });\n      }\n\n      const navigation = ref.current!;\n\n      unsubscribeAction = navigation.addListener('__unsafe_action__', (e) => {\n        const action = e.data.action;\n\n        if (e.data.noop) {\n          // Even if the state didn't change, it's useful to show the action\n          send({\n            type: 'action',\n            action,\n            state: lastStateRef.current,\n            stack: e.data.stack,\n          });\n        } else {\n          lastActionRef.current = e.data;\n        }\n      });\n\n      unsubscribeState = navigation.addListener('state', (e) => {\n        // Don't show the action in dev tools if the state is what we sent to reset earlier\n        if (\n          lastResetRef.current &&\n          deepEqual(lastResetRef.current, e.data.state)\n        ) {\n          lastStateRef.current = undefined;\n          return;\n        }\n\n        const state = navigation.getRootState();\n        const lastState = lastStateRef.current;\n        const lastChange = lastActionRef.current;\n\n        lastActionRef.current = undefined;\n        lastStateRef.current = state;\n\n        // If we don't have an action and the state didn't change, then it's probably extraneous\n        if (lastChange === undefined && deepEqual(state, lastState)) {\n          return;\n        }\n\n        send({\n          type: 'action',\n          action: lastChange ? lastChange.action : { type: '@@UNKNOWN' },\n          state,\n          stack: lastChange?.stack,\n        });\n      });\n    };\n\n    initialize();\n\n    return () => {\n      unsubscribeAction?.();\n      unsubscribeState?.();\n      clearTimeout(timer);\n    };\n  }, [ref, send]);\n\n  const resetRoot = React.useCallback(\n    (state: NavigationState) => {\n      if (ref.current) {\n        lastResetRef.current = state;\n        ref.current.resetRoot(state);\n      }\n    },\n    [ref]\n  );\n\n  return { resetRoot };\n}\n"]}