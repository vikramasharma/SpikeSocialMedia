{"version":3,"sources":["parseHermesStack.tsx"],"names":["RE_FRAME","RE_SKIPPED","parseLine","line","asFrame","match","type","functionName","location","sourceUrl","line1Based","Number","parseInt","virtualOffset0Based","column1Based","asSkipped","count","undefined","parseHermesStack","stack","lines","split","entries","lastMessageLine","i","length","entry","push","message","slice","join"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AA2CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMA,QAAQ,GACZ,yEADF,C,CAGA;AACA;;AACA,MAAMC,UAAU,GAAG,kCAAnB;;AAEA,SAASC,SAAT,CAAmBC,IAAnB,EAA+D;AAC7D,QAAMC,OAAO,GAAGD,IAAI,CAACE,KAAL,CAAWL,QAAX,CAAhB;;AACA,MAAII,OAAJ,EAAa;AACX,WAAO;AACLE,MAAAA,IAAI,EAAE,OADD;AAELC,MAAAA,YAAY,EAAEH,OAAO,CAAC,CAAD,CAFhB;AAGLI,MAAAA,QAAQ,EACNJ,OAAO,CAAC,CAAD,CAAP,KAAe,QAAf,GACI;AAAEE,QAAAA,IAAI,EAAE;AAAR,OADJ,GAEIF,OAAO,CAAC,CAAD,CAAP,KAAe,aAAf,GACA;AACEE,QAAAA,IAAI,EAAE,UADR;AAEEG,QAAAA,SAAS,EAAEL,OAAO,CAAC,CAAD,CAFpB;AAGEM,QAAAA,UAAU,EAAEC,MAAM,CAACC,QAAP,CAAgBR,OAAO,CAAC,CAAD,CAAvB,EAA4B,EAA5B,CAHd;AAIES,QAAAA,mBAAmB,EAAEF,MAAM,CAACC,QAAP,CAAgBR,OAAO,CAAC,CAAD,CAAvB,EAA4B,EAA5B;AAJvB,OADA,GAOA;AACEE,QAAAA,IAAI,EAAE,QADR;AAEEG,QAAAA,SAAS,EAAEL,OAAO,CAAC,CAAD,CAFpB;AAGEM,QAAAA,UAAU,EAAEC,MAAM,CAACC,QAAP,CAAgBR,OAAO,CAAC,CAAD,CAAvB,EAA4B,EAA5B,CAHd;AAIEU,QAAAA,YAAY,EAAEH,MAAM,CAACC,QAAP,CAAgBR,OAAO,CAAC,CAAD,CAAvB,EAA4B,EAA5B;AAJhB;AAbD,KAAP;AAoBD;;AACD,QAAMW,SAAS,GAAGZ,IAAI,CAACE,KAAL,CAAWJ,UAAX,CAAlB;;AACA,MAAIc,SAAJ,EAAe;AACb,WAAO;AACLT,MAAAA,IAAI,EAAE,SADD;AAELU,MAAAA,KAAK,EAAEL,MAAM,CAACC,QAAP,CAAgBG,SAAS,CAAC,CAAD,CAAzB,EAA8B,EAA9B;AAFF,KAAP;AAID;;AACD,SAAOE,SAAP;AACD;;AAED,eAAe,SAASC,gBAAT,CAA0BC,KAA1B,EAA4D;AACzE,QAAMC,KAAK,GAAGD,KAAK,CAACE,KAAN,CAAY,IAAZ,CAAd;AACA,MAAIC,OAAO,GAAG,EAAd;AACA,MAAIC,eAAe,GAAG,CAAC,CAAvB;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,KAAK,CAACK,MAA1B,EAAkC,EAAED,CAApC,EAAuC;AACrC,UAAMrB,IAAI,GAAGiB,KAAK,CAACI,CAAD,CAAlB;;AACA,QAAI,CAACrB,IAAL,EAAW;AACT;AACD;;AACD,UAAMuB,KAAK,GAAGxB,SAAS,CAACC,IAAD,CAAvB;;AACA,QAAIuB,KAAJ,EAAW;AACTJ,MAAAA,OAAO,CAACK,IAAR,CAAaD,KAAb;AACA;AACD,KAToC,CAUrC;;;AACAH,IAAAA,eAAe,GAAGC,CAAlB;AACAF,IAAAA,OAAO,GAAG,EAAV;AACD;;AACD,QAAMM,OAAO,GAAGR,KAAK,CAACS,KAAN,CAAY,CAAZ,EAAeN,eAAe,GAAG,CAAjC,EAAoCO,IAApC,CAAyC,IAAzC,CAAhB;AACA,SAAO;AAAEF,IAAAA,OAAF;AAAWN,IAAAA;AAAX,GAAP;AACD","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\ninterface HermesStackLocationNative {\n  type: 'NATIVE';\n}\n\ninterface HermesStackLocationSource {\n  type: 'SOURCE';\n  sourceUrl: string;\n  line1Based: number;\n  column1Based: number;\n}\n\ninterface HermesStackLocationBytecode {\n  type: 'BYTECODE';\n  sourceUrl: string;\n  line1Based: number;\n  virtualOffset0Based: number;\n}\n\ntype HermesStackLocation =\n  | HermesStackLocationNative\n  | HermesStackLocationSource\n  | HermesStackLocationBytecode;\n\ninterface HermesStackEntryFrame {\n  type: 'FRAME';\n  location: HermesStackLocation;\n  functionName: string;\n}\n\ninterface HermesStackEntrySkipped {\n  type: 'SKIPPED';\n  count: number;\n}\n\ntype HermesStackEntry = HermesStackEntryFrame | HermesStackEntrySkipped;\n\nexport interface HermesParsedStack {\n  message: string;\n  entries: HermesStackEntry[];\n}\n\n// Capturing groups:\n// 1. function name\n// 2. is this a native stack frame?\n// 3. is this a bytecode address or a source location?\n// 4. source URL (filename)\n// 5. line number (1 based)\n// 6. column number (1 based) or virtual offset (0 based)\nconst RE_FRAME =\n  /^ {0,4}at (.+?)(?: \\((native)\\)?| \\((address at )?(.*?):(\\d+):(\\d+)\\))$/;\n\n// Capturing groups:\n// 1. count of skipped frames\nconst RE_SKIPPED = /^ {0,4}... skipping (\\d) frames$/;\n\nfunction parseLine(line: string): HermesStackEntry | undefined {\n  const asFrame = line.match(RE_FRAME);\n  if (asFrame) {\n    return {\n      type: 'FRAME',\n      functionName: asFrame[1],\n      location:\n        asFrame[2] === 'native'\n          ? { type: 'NATIVE' }\n          : asFrame[3] === 'address at '\n          ? {\n              type: 'BYTECODE',\n              sourceUrl: asFrame[4],\n              line1Based: Number.parseInt(asFrame[5], 10),\n              virtualOffset0Based: Number.parseInt(asFrame[6], 10),\n            }\n          : {\n              type: 'SOURCE',\n              sourceUrl: asFrame[4],\n              line1Based: Number.parseInt(asFrame[5], 10),\n              column1Based: Number.parseInt(asFrame[6], 10),\n            },\n    };\n  }\n  const asSkipped = line.match(RE_SKIPPED);\n  if (asSkipped) {\n    return {\n      type: 'SKIPPED',\n      count: Number.parseInt(asSkipped[1], 10),\n    };\n  }\n  return undefined;\n}\n\nexport default function parseHermesStack(stack: string): HermesParsedStack {\n  const lines = stack.split(/\\n/);\n  let entries = [];\n  let lastMessageLine = -1;\n  for (let i = 0; i < lines.length; ++i) {\n    const line = lines[i];\n    if (!line) {\n      continue;\n    }\n    const entry = parseLine(line);\n    if (entry) {\n      entries.push(entry);\n      continue;\n    }\n    // No match - we're still in the message\n    lastMessageLine = i;\n    entries = [];\n  }\n  const message = lines.slice(0, lastMessageLine + 1).join('\\n');\n  return { message, entries };\n}\n"]}